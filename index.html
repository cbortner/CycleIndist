<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Skeletal Path Model – 5-Cycle House</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" />

  <style>
    body { font-family: sans-serif; margin: 20px; }
    svg  { border: 1px solid #ccc; }
    .node circle {
      fill: lightblue;
      stroke: steelblue;
      stroke-width: 2px;
    }
    .node text {
      font-size: 14px;
    }
    .eq-box {
      margin-top: 20px;
      padding: 10px;
      background-color: #f4f4f4;
      border-radius: 5px;
    }
  </style>
</head>

<body>
  <h2>Skeletal Path Model (5-Cycle House Shape)</h2>
  <p>Click a node to move the leak.</p>

  <div style="width:100%; display:flex; justify-content:center;">
    <svg width="100%" height="360" viewBox="0 0 600 360"></svg>
  </div>

  <div class="eq-box">
    <strong>Input-Output Equation:</strong>
    <div id="equation"></div>
  </div>

<script>
const RADIUS = 25;

/* -------------------------------------
   NODE POSITIONS (More spacing)
   -------------------------------------
         (2)
        /   \
     (1)     (3)
        \   /
         (5)
         |
         (4)
---------------------------------------- */

const nodePositions = [
  { x: 200, y: 150 },  // 1 (left middle)
  { x: 300, y:  80 },  // 2 (roof peak)
  { x: 400, y: 150 },  // 3 (right middle)
  { x: 400, y: 260 },  // 4 (bottom right)
  { x: 200, y: 260 },  // 5 (bottom left)
];

// 5-cycle: 1→2→3→4→5→1
const links = [
  { source:0, target:1, label:"a_{21}" },
  { source:1, target:2, label:"a_{32}" },
  { source:2, target:3, label:"a_{43}" },
  { source:3, target:4, label:"a_{54}" },
  { source:4, target:0, label:"a_{15}" },
];

let leakNode = 0;

const eqLookup = {
  0: "\\text{IO equation with leak in compartment 1 (placeholder)}",
  1: "\\text{IO equation with leak in compartment 2 (placeholder)}",
  2: "\\text{IO equation with leak in compartment 3 (placeholder)}",
  3: "\\text{IO equation with leak in compartment 4 (placeholder)}",
  4: "\\text{IO equation with leak in compartment 5 (placeholder)}",
};

const svg = d3.select("svg");

// Compute geometric center of the cycle (used for leak direction & could be reused)
const center = {
  x: d3.mean(nodePositions, p => p.x),
  y: d3.mean(nodePositions, p => p.y)
};

/* ---------- MARKERS ---------- */
const defs = svg.append("defs");

defs.append("marker").attr("id","link-arrow")
  .attr("viewBox","0 0 10 10").attr("refX",10).attr("refY",5)
  .attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto")
  .append("path").attr("d","M0 0 L10 5 L0 10 Z").attr("fill","gray");

defs.append("marker").attr("id","leak-arrow")
  .attr("viewBox","0 0 10 10").attr("refX",10).attr("refY",5)
  .attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto")
  .append("path").attr("d","M0 0 L10 5 L0 10 Z").attr("fill","red");

defs.append("marker").attr("id","arrow")
  .attr("viewBox","0 0 10 10").attr("refX",10).attr("refY",5)
  .attr("markerWidth",6).attr("markerHeight",6).attr("orient","auto-start-reverse")
  .append("path").attr("d","M0 0 L10 5 L0 10 Z").attr("fill","black");

/* ---------- NODES ---------- */
const node = svg.selectAll("g.node")
  .data(nodePositions)
  .enter()
  .append("g")
  .attr("class","node")
  .attr("transform", d => `translate(${d.x},${d.y})`)
  .on("click",(e,d)=>{
    leakNode = nodePositions.indexOf(d);
    drawLeak();
    updateEquation();
  });

node.append("circle").attr("r",RADIUS);

node.append("text")
  .text((d,i)=>i+1)
  .attr("dy",5)
  .attr("text-anchor","middle");

/* ---------- EDGES (trimmed to circle edges) ---------- */
svg.selectAll("line.link")
  .data(links)
  .enter()
  .append("line")
  .attr("class","link")
  .attr("stroke","gray")
  .attr("stroke-width",2)
  .attr("marker-end","url(#link-arrow)")
  .each(function(d){
    const s = nodePositions[d.source];
    const t = nodePositions[d.target];

    const dx = t.x - s.x;
    const dy = t.y - s.y;
    const L  = Math.hypot(dx,dy);
    const ux = dx / L;
    const uy = dy / L;

    this.x1.baseVal.value = s.x + ux * RADIUS;
    this.y1.baseVal.value = s.y + uy * RADIUS;
    this.x2.baseVal.value = t.x - ux * RADIUS;
    this.y2.baseVal.value = t.y - uy * RADIUS;
  });

/* ---------- EDGE LABELS (simple midpoint) ---------- */
svg.selectAll(".edge-label")
  .data(links)
  .enter()
  .append("foreignObject")
  .each(function(d){
    const s = nodePositions[d.source];
    const t = nodePositions[d.target];
    const midX = (s.x + t.x)/2;
    const midY = (s.y + t.y)/2;

    d3.select(this)
      .attr("x", midX - 20)
      .attr("y", midY - 15)
      .attr("width", 40)
      .attr("height", 30)
      .append("xhtml:div")
      .style("text-align","center")
      .style("font-size","14px")
      .each(function(){ katex.render(d.label,this,{throwOnError:false}); });
  });

/* ---------- INPUT (into 1) ---------- */
svg.append("line")
  .attr("x1", nodePositions[0].x - RADIUS - 60)
  .attr("y1", nodePositions[0].y)
  .attr("x2", nodePositions[0].x - RADIUS)
  .attr("y2", nodePositions[0].y)
  .attr("stroke","black").attr("stroke-width",3)
  .attr("marker-end","url(#arrow)");

svg.append("text")
  .attr("x", nodePositions[0].x - RADIUS - 75)
  .attr("y", nodePositions[0].y - 5)
  .text("in");

/* ---------- OUTPUT (from 3) ---------- */
svg.append("line")
  .attr("x1", nodePositions[2].x + RADIUS)
  .attr("y1", nodePositions[2].y)
  .attr("x2", nodePositions[2].x + RADIUS + 60)
  .attr("y2", nodePositions[2].y)
  .attr("stroke","black")
  .attr("stroke-width",3);

svg.append("circle")
  .attr("cx", nodePositions[2].x + RADIUS + 60)
  .attr("cy", nodePositions[2].y)
  .attr("r",5)
  .attr("fill","black");

svg.append("text")
  .attr("x", nodePositions[2].x + RADIUS + 75)
  .attr("y", nodePositions[2].y - 5)
  .text("out");

/* ---------- LEAK INDICATOR (always toward inside) ---------- */
function drawLeak(){
  svg.selectAll(".leak-indicator").remove();
  svg.selectAll(".leak-label").remove();

  const pos = nodePositions[leakNode];

  // Vector from node to center (points toward inside of the cycle)
  let vx = center.x - pos.x;
  let vy = center.y - pos.y;
  const vLen = Math.hypot(vx, vy);
  const ux = vx / vLen;
  const uy = vy / vLen;

  // Start just inside the node boundary
  const startX = pos.x + ux * RADIUS;
  const startY = pos.y + uy * RADIUS;

  // End further toward the center
  const leakLen = 35; // length of leak arrow
  const endX = startX + ux * leakLen;
  const endY = startY + uy * leakLen;

  svg.append("line")
    .attr("class","leak-indicator")
    .attr("x1", startX)
    .attr("y1", startY)
    .attr("x2", endX)
    .attr("y2", endY)
    .attr("stroke","red")
    .attr("stroke-width",2)
    .attr("marker-end","url(#leak-arrow)");

  // Place leak label slightly beyond the arrow tip, still toward the center
  const labelOffset = 10;
  const labelX = endX + ux * labelOffset;
  const labelY = endY + uy * labelOffset;

  svg.append("foreignObject")
    .attr("class","leak-label")
    .attr("x", labelX - 20)
    .attr("y", labelY - 15)
    .attr("width",50)
    .attr("height",30)
    .append("xhtml:div")
    .style("color","red")
    .style("text-align","center")
    .style("font-size","14px")
    .each(function(){
      katex.render(`a_{0${leakNode+1}}`, this, { throwOnError:false });
    });
}

/* ---------- EQUATION ---------- */
function updateEquation(){
  katex.render(eqLookup[leakNode], document.getElementById("equation"), {
    throwOnError:false
  });
}

// Initial draw
drawLeak();
updateEquation();

</script>
</body>
</html>
