<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Directed Cycle Model Indistinguishability</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" />

  <style>
    body { font-family: sans-serif; margin: 20px; }
    svg  { border: 1px solid #ccc; }
    .node circle {
      fill: lightblue;
      stroke: steelblue;
      stroke-width: 2px;
    }
    .node text { font-size: 14px; }
    .eq-box {
      margin-top: 20px; padding: 10px;
      background-color: #f4f4f4; border-radius: 5px;
    }
  </style>
</head>

<body>
  <h2>Directed Cycle Model Indistinguishability</h2>
  <p>Click a node to move the leak.</p>

  <div style="width:100%; display:flex; justify-content:center;">
    <svg width="100%" height="360" viewBox="0 0 600 360"></svg>
  </div>

  <div class="eq-box">
    <strong>Input-Output Equation:</strong>
    <div id="equation"></div>
  </div>

<script>
const RADIUS = 25;

/* --------------------------
   HOUSE-SHAPE GEOMETRY
   -------------------------- */

const nodePositions = [
  { x: 200, y: 150 },  // 1 (left middle)
  { x: 300, y:  80 },  // 2 (roof peak)
  { x: 400, y: 150 },  // 3 (right middle)
  { x: 400, y: 260 },  // 4 (bottom right)
  { x: 200, y: 260 },  // 5 (bottom left)
];

// 5-cycle: 1→2→3→4→5→1
const links = [
  { source:0, target:1, label:"a_{21}" },
  { source:1, target:2, label:"a_{32}" },
  { source:2, target:3, label:"a_{43}" },
  { source:3, target:4, label:"a_{54}" },
  { source:4, target:0, label:"a_{15}" },
];

let leakNode = 0;

// placeholder IO eqns
const eqLookup = {
  0: "\\text{IO equation with leak in compartment 1 (placeholder)}",
  1: "\\text{IO equation with leak in compartment 2 (placeholder)}",
  2: "\\text{IO equation with leak in compartment 3 (placeholder)}",
  3: "\\text{IO equation with leak in compartment 4 (placeholder)}",
  4: "\\text{IO equation with leak in compartment 5 (placeholder)}",
};

const svg = d3.select("svg");

// Compute cycle center for label placement & leak direction
const center = {
  x: d3.mean(nodePositions, p => p.x),
  y: d3.mean(nodePositions, p => p.y)
};

/* ---------- MARKERS ---------- */

const defs = svg.append("defs");

defs.append("marker").attr("id","link-arrow")
  .attr("viewBox","0 0 10 10")
  .attr("refX",10).attr("refY",5)
  .attr("markerWidth",6).attr("markerHeight",6)
  .attr("orient","auto")
  .append("path").attr("d","M0 0 L10 5 L0 10 Z").attr("fill","gray");

defs.append("marker").attr("id","leak-arrow")
  .attr("viewBox","0 0 10 10")
  .attr("refX",10).attr("refY",5)
  .attr("markerWidth",6).attr("markerHeight",6)
  .attr("orient","auto")
  .append("path").attr("d","M0 0 L10 5 L0 10 Z").attr("fill","red");

defs.append("marker").attr("id","arrow")
  .attr("viewBox","0 0 10 10")
  .attr("refX",10).attr("refY",5)
  .attr("markerWidth",6).attr("markerHeight",6)
  .attr("orient","auto-start-reverse")
  .append("path").attr("d","M0 0 L10 5 L0 10 Z").attr("fill","black");

/* ---------- NODES ---------- */

const node = svg.selectAll("g.node")
  .data(nodePositions)
  .enter()
  .append("g")
  .attr("class","node")
  .attr("transform", d => `translate(${d.x},${d.y})`)
  .on("click",(e,d)=>{
    leakNode = nodePositions.indexOf(d);
    drawLeak();
    updateEquation();
  });

node.append("circle").attr("r",RADIUS);
node.append("text")
  .text((d,i)=>i+1)
  .attr("dy",5)
  .attr("text-anchor","middle");

/* ---------- EDGES (trimmed to circle edges) ---------- */

svg.selectAll("line.link")
  .data(links)
  .enter()
  .append("line")
  .attr("class","link")
  .attr("stroke","gray")
  .attr("stroke-width",2)
  .attr("marker-end","url(#link-arrow)")
  .each(function(d){
    const s = nodePositions[d.source];
    const t = nodePositions[d.target];

    const dx = t.x - s.x, dy = t.y - s.y;
    const L  = Math.hypot(dx,dy);
    const ux = dx / L, uy = dy / L;

    // trimmed edges
    this.x1.baseVal.value = s.x + ux * RADIUS;
    this.y1.baseVal.value = s.y + uy * RADIUS;
    this.x2.baseVal.value = t.x - ux * RADIUS;
    this.y2.baseVal.value = t.y - uy * RADIUS;
  });

/* ---------- EDGE LABELS (offset off each edge) ---------- */

svg.selectAll(".edge-label")
  .data(links)
  .enter()
  .append("foreignObject")
  .each(function(d){

    const s = nodePositions[d.source];
    const t = nodePositions[d.target];

    const dx = t.x - s.x;
    const dy = t.y - s.y;
    const L  = Math.hypot(dx, dy);
    const ux = dx / L, uy = dy / L;

    // Trimmed endpoints
    const ex1 = s.x + ux * RADIUS;
    const ey1 = s.y + uy * RADIUS;
    const ex2 = t.x - ux * RADIUS;
    const ey2 = t.y - uy * RADIUS;

    // Edge midpoint
    const mx = (ex1 + ex2) / 2;
    const my = (ey1 + ey2) / 2;

    // Perpendicular direction (two possibilities)
    let px = -uy;
    let py =  ux;

    // choose direction farther FROM the center
    const mid_to_center_x = mx - center.x;
    const mid_to_center_y = my - center.y;

    const dot = px * mid_to_center_x + py * mid_to_center_y;
    if (dot < 0) { px *= -1; py *= -1; }

    const offset = 18; // label distance from edge
    const lx = mx + px * offset;
    const ly = my + py * offset;

    d3.select(this)
      .attr("x", lx - 20)
      .attr("y", ly - 15)
      .attr("width", 40)
      .attr("height", 30)
      .append("xhtml:div")
      .style("text-align","center")
      .style("font-size","14px")
      .each(function(){
        katex.render(d.label, this, { throwOnError:false });
      });
  });

/* ---------- INPUT (into node 1) ---------- */

svg.append("line")
  .attr("x1", nodePositions[0].x - RADIUS - 60)
  .attr("y1", nodePositions[0].y)
  .attr("x2", nodePositions[0].x - RADIUS)
  .attr("y2", nodePositions[0].y)
  .attr("stroke","black")
  .attr("stroke-width",3)
  .attr("marker-end","url(#arrow)");

svg.append("text")
  .attr("x", nodePositions[0].x - RADIUS - 75)
  .attr("y", nodePositions[0].y - 5)
  .text("in");

/* ---------- OUTPUT (from 3) ---------- */

svg.append("line")
  .attr("x1", nodePositions[2].x + RADIUS)
  .attr("y1", nodePositions[2].y)
  .attr("x2", nodePositions[2].x + RADIUS + 60)
  .attr("y2", nodePositions[2].y)
  .attr("stroke","black")
  .attr("stroke-width",3);

svg.append("circle")
  .attr("cx", nodePositions[2].x + RADIUS + 60)
  .attr("cy", nodePositions[2].y)
  .attr("r",5)
  .attr("fill","black");

svg.append("text")
  .attr("x", nodePositions[2].x + RADIUS + 75)
  .attr("y", nodePositions[2].y - 5)
  .text("out");

/* ---------- LEAK (always pointing inward) ---------- */

function drawLeak(){
  svg.selectAll(".leak-indicator").remove();
  svg.selectAll(".leak-label").remove();

  const pos = nodePositions[leakNode];

  let vx = center.x - pos.x;
  let vy = center.y - pos.y;
  const vLen = Math.hypot(vx, vy);
  const ux = vx / vLen;
  const uy = vy / vLen;

  const startX = pos.x + ux * RADIUS;
  const startY = pos.y + uy * RADIUS;

  const leakLen = 35;
  const endX = startX + ux * leakLen;
  const endY = startY + uy * leakLen;

  svg.append("line")
    .attr("class","leak-indicator")
    .attr("x1", startX)
    .attr("y1", startY)
    .attr("x2", endX)
    .attr("y2", endY)
    .attr("stroke","red")
    .attr("stroke-width",2)
    .attr("marker-end","url(#leak-arrow)");

  // label slightly inward
  const labelX = endX + ux * 10;
  const labelY = endY + uy * 10;

  svg.append("foreignObject")
    .attr("class","leak-label")
    .attr("x", labelX - 20)
    .attr("y", labelY - 15)
    .attr("width", 50)
    .attr("height", 30)
    .append("xhtml:div")
    .style("color","red")
    .style("text-align","center")
    .style("font-size","14px")
    .each(function(){
      katex.render(`a_{0${leakNode+1}}`, this, { throwOnError:false });
    });
}

/* ---------- EQUATION ---------- */

function updateEquation(){
  katex.render(eqLookup[leakNode], document.getElementById("equation"), {
    throwOnError:false
  });
}

drawLeak();
updateEquation();

</script>
</body>
</html>
